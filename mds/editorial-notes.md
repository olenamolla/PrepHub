# PrepHub Editorial Notes: DRF API Flow (Serializer → ViewSet → Router)

These notes summarize the core concepts behind the API we just built, so you can revisit the “what/why/how” quickly while learning.

## Architecture Layers (where we are)
- Model (Data): Django ORM model — defines DB schema (e.g., `Problem`).
- Serializer (Shape/Validation): Translates between model instances and JSON, validates input (`ProblemSerializer`).
- ViewSet (Controller): Bundles CRUD actions and orchestrates flow (`ProblemViewSet`).
- Router + URLConf (Routing): Generates RESTful endpoints and plugs them into Django URLs.

## Data Flow (request lifecycle)
Client → URLConf → Router → ViewSet action → Queryset (DB) → Serializer → JSON Response

Example: GET /api/problems/
1. URLConf matches `path('api/', include(router.urls))`
2. Router matches `problems/` registered to `ProblemViewSet`
3. HTTP GET triggers `.list()` action (provided by `ModelViewSet`)
4. `queryset` fetches data from DB
5. `serializer_class` converts queryset into JSON
6. DRF returns JSON (and browsable API view in browser)

## Programmatic Objects and Their Roles
- `router = DefaultRouter()` → instance that builds URL patterns
- `router.register('problems', ProblemViewSet)` → binds URL prefix to a ViewSet class (not an instance)
- `router.urls` → property: list of URL patterns auto-generated by the router
- `include(router.urls)` → nests those URLs under a path prefix (here, `/api/`)
- `urlpatterns = [...]` → Django’s required list of URL patterns

## Why Subclass These Base Classes?
- `serializers.ModelSerializer`:
  - Auto-creates fields from the model; includes default `create`/`update` and basic validation.
  - `Meta.model` points to the model class; `Meta.fields` declares which fields are exposed.
- `viewsets.ModelViewSet`:
  - Provides complete CRUD actions: `list`, `retrieve`, `create`, `update`, `partial_update`, `destroy`.
  - You configure two key attributes: `queryset`, `serializer_class`.
- Router:
  - Eliminates URL boilerplate; generates consistent RESTful routes.

## Minimal Checklist to Add a New Resource
1) Model: Define your Django model (DB schema)
2) Serializer: Create `XSerializer(ModelSerializer)` with `Meta.model` and `Meta.fields`
3) ViewSet: Create `XViewSet(ModelViewSet)` with `queryset`, `serializer_class`
4) Router: `router.register('x', XViewSet)` and `include(router.urls)` under a prefix

## Common Pitfalls
- Name collisions: Don’t name your ViewSet the same as your Model (e.g., `ProblemViewSet` vs `Problem`).
- Missing imports: `from rest_framework import viewsets, routers`; `from django.urls import include, path`.
- CSRF & POST: Browsers enforce CSRF for session-auth; use the browsable API or BasicAuth during early testing.

## Useful Docs
- DRF ModelSerializer: https://www.django-rest-framework.org/api-guide/serializers/#modelserializer
- DRF ViewSets / ModelViewSet: https://www.django-rest-framework.org/api-guide/viewsets/#modelviewset
- DRF Routers: https://www.django-rest-framework.org/api-guide/routers/
- Django URLs include(): https://docs.djangoproject.com/en/5.2/topics/http/urls/#including-other-urlconfs

---

## How to Test Locally (manual)
1) Start server: `python backend/manage.py runserver`
2) In browser, open: `http://127.0.0.1:8000/api/problems/`
   - Expect: browsable API with an empty list (or items if you added any)
3) Option A: Create a problem via Django Admin (`/admin/`), refresh API page to see JSON
4) Option B: Use the browsable API form on `/api/problems/` to POST (browser provides CSRF token)

Tip: If POST via curl returns 403 (CSRF), use the browsable API or add BasicAuth temporarily in DRF settings for non-browser clients.


