# PrepHub Editorial Notes: DRF API Flow (Serializer → ViewSet → Router)

These notes summarize the core concepts behind the API we just built, so you can revisit the “what/why/how” quickly while learning.

## Architecture Layers (where we are)
- Model (Data): Django ORM model — defines DB schema (e.g., `Problem`).
- Serializer (Shape/Validation): Translates between model instances and JSON, validates input (`ProblemSerializer`).
- ViewSet (Controller): Bundles CRUD actions and orchestrates flow (`ProblemViewSet`).
- Router + URLConf (Routing): Generates RESTful endpoints and plugs them into Django URLs.

## Data Flow (request lifecycle)
Client → URLConf → Router → ViewSet action → Queryset (DB) → Serializer → JSON Response

Example: GET /api/problems/
1. URLConf matches `path('api/', include(router.urls))`
2. Router matches `problems/` registered to `ProblemViewSet`
3. HTTP GET triggers `.list()` action (provided by `ModelViewSet`)
4. `queryset` fetches data from DB
5. `serializer_class` converts queryset into JSON
6. DRF returns JSON (and browsable API view in browser)

## Programmatic Objects and Their Roles
- `router = DefaultRouter()` → instance that builds URL patterns
- `router.register('problems', ProblemViewSet)` → binds URL prefix to a ViewSet class (not an instance)
- `router.urls` → property: list of URL patterns auto-generated by the router
- `include(router.urls)` → nests those URLs under a path prefix (here, `/api/`)
- `urlpatterns = [...]` → Django’s required list of URL patterns

## Why Subclass These Base Classes?
- `serializers.ModelSerializer`:
  - Auto-creates fields from the model; includes default `create`/`update` and basic validation.
  - `Meta.model` points to the model class; `Meta.fields` declares which fields are exposed.
- `viewsets.ModelViewSet`:
  - Provides complete CRUD actions: `list`, `retrieve`, `create`, `update`, `partial_update`, `destroy`.
  - You configure two key attributes: `queryset`, `serializer_class`.
- Router:
  - Eliminates URL boilerplate; generates consistent RESTful routes.

## Minimal Checklist to Add a New Resource
1) Model: Define your Django model (DB schema)
2) Serializer: Create `XSerializer(ModelSerializer)` with `Meta.model` and `Meta.fields`
3) ViewSet: Create `XViewSet(ModelViewSet)` with `queryset`, `serializer_class`
4) Router: `router.register('x', XViewSet)` and `include(router.urls)` under a prefix

## Common Pitfalls
- Name collisions: Don’t name your ViewSet the same as your Model (e.g., `ProblemViewSet` vs `Problem`).
- Missing imports: `from rest_framework import viewsets, routers`; `from django.urls import include, path`.
- CSRF & POST: Browsers enforce CSRF for session-auth; use the browsable API or BasicAuth during early testing.

## Useful Docs
- DRF ModelSerializer: https://www.django-rest-framework.org/api-guide/serializers/#modelserializer
- DRF ViewSets / ModelViewSet: https://www.django-rest-framework.org/api-guide/viewsets/#modelviewset
- DRF Routers: https://www.django-rest-framework.org/api-guide/routers/
- Django URLs include(): https://docs.djangoproject.com/en/5.2/topics/http/urls/#including-other-urlconfs

---

## How to Test Locally (manual)
1) Start server: `python backend/manage.py runserver`
2) In browser, open: `http://127.0.0.1:8000/api/problems/`
   - Expect: browsable API with an empty list (or items if you added any)
3) Option A: Create a problem via Django Admin (`/admin/`), refresh API page to see JSON
4) Option B: Use the browsable API form on `/api/problems/` to POST (browser provides CSRF token)

Tip: If POST via curl returns 403 (CSRF), use the browsable API or add BasicAuth temporarily in DRF settings for non-browser clients.

---

## Testing Layer: Key Concepts Summary

### Where Testing Fits in Architecture
- **Layer:** Quality Assurance / Automated Verification
- **Purpose:** Calls your API like a real client; verifies behavior automatically
- **Isolation:** Uses a temporary test database (created/destroyed each run)

### Test Data Flow
```
Test Code (APITestCase) → Test Client → Django URLConf → Router → ViewSet → Serializer → Test DB
                                                                              ↓
Test Code ← Assert results ← Response ← Serializer ← Test DB
```

### Key Testing Concepts

| Concept | What It Is | Why It Matters |
|---------|-----------|----------------|
| `APITestCase` | Base class for API tests | Provides test client & DB isolation |
| `setUp()` | Runs before each test method | Avoids repeating setup code |
| `self.client` | Test HTTP client (APIClient) | Makes requests without a browser |
| `reverse()` | URL name → path converter | Tests don't break if URLs change |
| `format='json'` | Serialize dict → JSON | Mimics real API requests |
| Assertions | Verify expected behavior | Tests fail if behavior changes |
| Test DB | Temporary database | Each test starts fresh, no side effects |

### The Test Pattern (Arrange-Act-Assert)
1. **Arrange:** Set up data/state (in setUp or test method)
2. **Act:** Make a request (`self.client.get()` / `.post()` / etc.)
3. **Assert:** Check status code, response data, DB state

### How Assertions and ViewSet Methods Connect
**Important:** Assertions don't call ViewSet methods—the test client does.

Flow:
1. `self.client.post(url, payload)` → makes HTTP POST request
2. Django routes request → Router → `ProblemViewSet.create()` (auto-provided by ModelViewSet)
3. `create()` validates via serializer, saves to DB, returns Response with status 201
4. Response returns to test code
5. `self.assertEqual(resp.status_code, 201)` → **passively checks** what `create()` returned

**Key insight:** The test client triggers the full request chain; assertions verify the outcome.

### Common Test Assertions
- `assertEqual(resp.status_code, 200)` → HTTP OK
- `assertEqual(resp.status_code, 201)` → HTTP Created
- `assertEqual(resp.status_code, 400)` → HTTP Bad Request (validation failed)
- `assertIsInstance(resp.json(), list)` → Response is a JSON array
- `assertEqual(Model.objects.count(), 1)` → DB has 1 record
- `assertIn('field_name', resp.data)` → Error response includes field

### Running Tests
```bash
python backend/manage.py test problems
```

### Testing Docs
- DRF Testing: https://www.django-rest-framework.org/api-guide/testing/
- Django Testing: https://docs.djangoproject.com/en/5.2/topics/testing/overview/
- HTTP Status Codes: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status


---

## Frontend Integration: React + Vite + TypeScript + Axios

### Where This Sits in the Architecture
- Layer: Client/UI (runs in the browser, served locally by Vite during development)
- Responsibility: Render views, collect user input, call the REST API, display results and errors

### End-to-End Data Flow (SPA)
Browser → React (components/hooks) → Axios (HTTP client) → DRF (Router → ViewSet → Serializer → DB)
                                                  ↖ JSON Response ←———————————————↙

### Key Concepts and Why They Matter
- Vite dev server (usually http://localhost:5173): Fast reloads and modern build pipeline. It’s a separate origin from the API, so CORS must allow it.
  - Docs: https://vitejs.dev/guide/
- Axios instance: Centralizes `baseURL` and later auth (JWT) via interceptors; reduces boilerplate across components.
  - Docs: https://axios-http.com/docs/instance
- TypeScript interface (e.g., `Problem`): A contract for API data shape that catches mistakes early (e.g., missing fields or typos).
  - Docs: https://www.typescriptlang.org/docs/handbook/interfaces.html
- React hooks for data fetching:
  - `useEffect` triggers the fetch on mount
  - `useState` stores loading/error/data
  - Docs: https://react.dev/reference/react

### Minimal Fetch Pattern (What Happens Conceptually)
1) On component mount, call `GET /api/problems/`
2) While waiting, show a loading state
3) On success, store the list and render it
4) On error, store the error message and render an error UI

### CORS in Practice (during development)
- The browser enforces CORS. When the frontend (5173) calls the API (8000), the request is cross-origin.
- `django-cors-headers` adds `Access-Control-Allow-*` headers if the `Origin` is allowed:
  - Preflight (OPTIONS) → middleware responds with allowed methods/headers
  - Actual request (GET/POST) → response includes `Access-Control-Allow-Origin`
- Ensure the exact dev origins are allowed:
  - `http://localhost:5173`, `http://127.0.0.1:5173`
  - Docs: https://github.com/adamchainz/django-cors-headers

### Common Pitfalls and Fixes
- Endpoint typos (e.g., `/problmes/` vs `/problems/`) → 404 or network error
- Server not running → network error; check backend terminal
- Wrong `Origin` in CORS or missing dev origin → no `Access-Control-Allow-Origin` header
- Shape mismatch → TypeScript errors or undefined fields at runtime

### Preparing for Auth (Next Iteration)
- Introduce JWT with `djangorestframework-simplejwt` (`/api/token/`, `/api/token/refresh`).
- In Axios, add an interceptor to attach `Authorization: Bearer <token>`.
- Handle 401/403 globally (refresh token or redirect to login).
- Docs: https://django-rest-framework-simplejwt.readthedocs.io/


